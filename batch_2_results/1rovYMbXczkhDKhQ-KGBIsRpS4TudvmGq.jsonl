{"role": "User", "content": "Could you help me refactor this greedy algorithm that's supposed to find the minimum number of platforms needed at a railway station to avoid any delay in arrival of any train? I'd like it to also return the schedule of trains (as pairs of arrival and departure times) for each platform. Here's the current code: ```python def findPlatform(arrival, departure): arrival.sort() departure.sort() plat_needed = 1 result = 1 i = 1 j = 0 while i < len(arrival) and j < len(departure): if arrival[i] <= departure[j]: plat_needed += 1 i += 1 else: plat_needed -= 1 j += 1 if plat_needed > result: result = plat_needed return result ```", "type": "markdown"}
{"role": "Assistant", "content": "In order to achieved what you have asked, you will need to use a much more complex or detailed code so that we can track which train goes to which platform properly.\n\nHere is good way to go about this:", "type": "markdown"}
{"role": "Assistant", "content": "def findPlatform(arrival, departure):\n    events = sorted([(t, 'a') for t in arrival] + [(t, 'd') for t in departure])\n\n    plat_needed = 0\n    max_plat_needed = 0\n    platform_schedule = {}\n    current_trains = []\n\n    for time, event in events:\n        if event == 'a':\n            plat_needed += 1\n            current_trains.append(time)\n            if plat_needed > max_plat_needed:\n                max_plat_needed = plat_needed\n                platform_schedule[max_plat_needed] = [current_trains[-1]]\n        else:\n            plat_needed -= 1\n            departure_train = next((train for train in current_trains if train <= time), None)\n            if departure_train:\n                current_trains.remove(departure_train)\n                for p in range(1, max_plat_needed + 1):\n                    if platform_schedule.get(p) and platform_schedule[p][-1] == departure_train:\n                        platform_schedule[p].append(time)\n                        break\n            else:\n                # In case there's no matching arrival (should not happen in a correct input)\n                continue\n\n    # Convert the schedule to pairs of arrival and departure for each platform\n    final_schedule = {p: [(platform_schedule[p][i], platform_schedule[p][i+1]) for i in range(0, len(platform_schedule[p]), 2)] for p in platform_schedule}\n\n    return max_plat_needed, final_schedule\n\n\n# Example usage\narrival = [900, 940, 950, 1100, 1500, 1800]\ndeparture = [910, 1200, 1120, 1130, 1900, 2000]\n\nplatforms_needed, schedule = findPlatform(arrival, departure)\nprint(\"Minimum Number of Platforms Required =\", platforms_needed)\nprint(\"Platform Schedule =\", schedule)", "type": "code"}
